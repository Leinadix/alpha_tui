#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import re
import sys
from pathlib import Path

def parse_kernel_tbl(tbl_path: Path):
    """
    Liest arch/x86/entry/syscalls/syscall_64.tbl ein und gibt eine Liste
    von (nr: int, name: str) für ABI common/64/x32 zurück.
    """
    entries = []
    for line in tbl_path.read_text().splitlines():
        line = line.split('#',1)[0].strip()
        if not line:
            continue
        parts = re.split(r'\s+', line)
        if len(parts) < 4:
            continue
        nr_str, abi, name, _ = parts[:4]
        if abi not in ('common', '64', 'x32'):
            continue
        try:
            nr = int(nr_str)
        except ValueError:
            continue
        entries.append((nr, name))
    return entries

def find_define_arg_types(name: str, kernel_root: Path):
    """
    Sucht in allen .c-Dateien unter kernel_root nach
    SYSCALL_DEFINE<n>(name, [Typ, arg, Typ, arg, ...]) {
    und extrahiert die Typen an den geraden Indizes.
    Gibt List[str] zurück oder None, wenn nicht gefunden.
    """
    pattern = re.compile(
        rf"SYSCALL_DEFINE(?P<n>\d+)\s*\(\s*{re.escape(name)}"
        r"(?:\s*,\s*(?P<blob>.*?))?\)\s*\{",
        re.DOTALL
    )
    for cfile in kernel_root.rglob('*.c'):
        text = cfile.read_text(errors='ignore')
        for m in pattern.finditer(text):
            n_args = int(m.group('n'))
            blob = m.group('blob') or ""
            tokens = [tok.strip() for tok in blob.split(',') if tok.strip()]
            types = tokens[0:2*n_args:2]
            if len(types) == n_args:
                return types
    return None

def main():
    if len(sys.argv) != 3:
        print(f"Usage: {sys.argv[0]} <path/to/syscall_64.tbl> <path/to/linux-root> > src/instructions/syscalls.rs\n You can try this:\n\t>> git clone --depth=1 https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git <<\n Your tbl file should then be somewhere here:\n\tlinux/arch/<your arch>/.../syscall_<32/64>.tbl ", file=sys.stderr)
        sys.exit(1)

    tbl_path = Path(sys.argv[1])
    linux_root = Path(sys.argv[2])

    if not tbl_path.exists() or not linux_root.is_dir():
        print("Pfad zum tbl oder Linux-Root ist falsch.", file=sys.stderr)
        sys.exit(1)

    entries = parse_kernel_tbl(tbl_path)
    print(f"# Gefundene Syscalls: {len(entries)}", file=sys.stderr)

    flags_map = {}
    for nr, name in entries:
        types = find_define_arg_types(name, linux_root)
        if types is None:
            flags_map[nr] = None
            print(f"  [!]  {name} ({nr}): kein SYSCALL_DEFINE gefunden", file=sys.stderr)
        else:
            flags = [('*' in t) for t in types]
            flags_map[nr] = flags
            print(f"  [X] {name} ({nr}): {flags}", file=sys.stderr)

    print("// @automatically generated by generate_ptr_flags.rs.py - do not edit")
    print("pub fn pointer_flags(sysno: u32) -> Option<&'static [bool]> {")
    print("    match sysno {")
    for nr in sorted(flags_map):
        flags = flags_map[nr]
        if flags is None:
            continue
        bools = ", ".join("true" if b else "false" for b in flags)
        print(f"        {nr} => Some(&[{bools}]),")
    print("        _ => None,")
    print("    }")
    print("}")

if __name__ == '__main__':
    main()
